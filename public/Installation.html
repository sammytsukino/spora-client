<!doctype html>
<html lang="en" class="hide-scrollbar">

<head>
    <meta charset="UTF-8" />
    <title>SPORA LABORATORY</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
        href="https://fonts.googleapis.com/css2?family=BIZ+UDMincho&family=BioRhyme:wght@400;800&family=Cormorant+Garamond:ital,wght@0,400;0,700;1,400&family=DM+Sans:ital,wght@0,400;0,700;1,400&family=Darker+Grotesque:wght@400;900&family=Eczar:wght@400;800&family=Gloock&family=Grenze+Gotisch:wght@400;700&family=Inter:wght@400;700&family=JetBrains+Mono:wght@400;800&family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&family=Playfair+Display:ital,wght@0,400;0,700;1,400&family=Space+Mono:ital,wght@0,400;0,700;1,400&family=Syne:wght@400;800&family=Xanh+Mono:ital@0;1&display=swap"
        rel="stylesheet" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        :root {
            --spora-bg-ui: #e6e6e6;
            --spora-dark: #262626;
            --spora-lime: #bbf451;
            --spora-white: #ffffff;
            --font-main: "BIZ UDMincho", serif;
            --font-mono: "Jetbrains Mono", monospace;
        }

        ::selection {
            background: var(--spora-lime);
            color: var(--spora-dark);
        }

        body {
            margin: 0;
            background: #000;
            color: var(--spora-dark);
            font-family: var(--font-main);
            height: 100dvh;
            overflow: hidden;
            display: flex;
        }

        #ui {
            width: 24vw;
            min-width: 320px;
            height: 100%;
            background: var(--spora-bg-ui);
            border-right: 2px solid var(--spora-dark);
            padding: 30px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 28px;
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 10;
        }

        #ui.is-locked input,
        #ui.is-locked textarea,
        #ui.is-locked select,
        #ui.is-locked button {
            pointer-events: none;
            opacity: 0.45;
        }

        #ui::-webkit-scrollbar {
            width: 0px;
            background: transparent;
        }

        h2 {
            margin: 0 0 10px 0;
            font-family: var(--font-mono);
            font-size: 11px;
            color: var(--spora-dark);
            text-transform: uppercase;
            letter-spacing: 0.25em;
            font-weight: 700;
        }

        section {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-box {
            border: 2px solid var(--spora-dark);
            background: transparent;
            padding: 10px;
            transition: all 0.2s ease;
        }

        .control-box:focus-within {
            border-color: var(--spora-dark);
            box-shadow: 4px 4px 0px var(--spora-lime);
        }

        .row-h {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        label {
            font-family: var(--font-mono);
            font-size: 10px;
            color: var(--spora-dark);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-weight: 700;
        }

        textarea,
        input[type="text"],
        [contenteditable="true"] {
            width: 100%;
            background: transparent;
            border: none;
            color: var(--spora-dark);
            font-family: var(--font-main);
            font-size: 13px;
            line-height: 1.5;
            outline: none;
            resize: none;
            padding: 0;
            margin: 0;
            font-weight: 400;
        }

        textarea, [contenteditable="true"] {
            height: 100px;
        }

        textarea::placeholder, [contenteditable="true"]:empty:before {
            color: #888;
            opacity: 1;
            font-style: italic;
        }
        
        [contenteditable="true"]:empty:before {
            content: attr(data-placeholder);
        }
        
        .base-text {
            color: #666;
            opacity: 0.75;
        }
        
        .new-text {
            color: var(--spora-dark);
        }

        #txtInp::-webkit-scrollbar {
            width: 8px;
            background: transparent;
        }

        #txtInp::-webkit-scrollbar-thumb {
            background: var(--spora-dark);
            border-radius: 8px;
        }

        #txtInp {
            scrollbar-width: thin;
            scrollbar-color: var(--spora-dark) transparent;
        }

        .confirm-modal-overlay {
            position: fixed;
            inset: 0;
            z-index: 40;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            animation: fadeIn 0.2s ease-out;
        }

        .confirm-modal-overlay.is-open {
            display: flex;
        }

        .confirm-modal {
            background: var(--spora-bg-ui);
            border: 2px solid var(--spora-dark);
            max-width: 440px;
            width: 90%;
            padding: 22px 24px;
            box-shadow: 0 0 0 4px var(--spora-dark);
            animation: slideUp 0.3s ease-out;
        }

        .confirm-modal-title {
            font-family: var(--font-main);
            font-weight: 700;
            font-size: 20px;
            margin: 0 0 12px 0;
            color: var(--spora-dark);
        }

        .confirm-modal-desc {
            font-family: var(--font-mono);
            font-size: 11px;
            margin: 0 0 18px 0;
            color: var(--spora-dark);
        }

        .confirm-modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            font-family: var(--font-mono);
            font-size: 11px;
        }

        .confirm-modal-btn {
            padding: 10px 14px;
            border: 2px solid var(--spora-dark);
            text-transform: uppercase;
            letter-spacing: 0.25em;
            cursor: pointer;
            background: var(--spora-bg-ui);
            color: var(--spora-dark);
        }

        .confirm-modal-btn-confirm {
            background: var(--spora-dark);
            color: var(--spora-bg-ui);
        }

        .confirm-modal-btn:hover {
            background: #f5f5f5;
        }

        .confirm-modal-btn-confirm:hover {
            background: #000;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes slideUp {
            from {
                transform: translateY(10px);
            }

            to {
                transform: translateY(0);
            }
        }

        select {
            width: 100%;
            background: transparent;
            border: none;
            color: var(--spora-dark);
            font-family: var(--font-mono);
            font-size: 11px;
            text-transform: uppercase;
            cursor: pointer;
            outline: none;
            appearance: none;
            -webkit-appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23262626' stroke-width='2' stroke-linecap='square' stroke-linejoin='arcs'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 0 center;
            background-size: 16px;
        }

        input[type="range"] {
            appearance: none;
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
            margin: 10px 0;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 2px;
            background: var(--spora-dark);
            border: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            -webkit-appearance: none;
            height: 14px;
            width: 14px;
            background: var(--spora-dark);
            border: 2px solid var(--spora-dark);
            margin-top: -6px;
            cursor: pointer;
            transition: background 0.2s;
        }

        input[type="range"]:hover::-webkit-slider-thumb {
            background: var(--spora-lime);
        }

        input[type="checkbox"] {
            appearance: none;
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border: 2px solid var(--spora-dark);
            background: transparent;
            cursor: pointer;
            position: relative;
            margin: 0;
        }

        input[type="checkbox"]:checked {
            background: var(--spora-lime);
            box-shadow: inset 0 0 0 2px var(--spora-dark);
        }

        input[type="color"] {
            width: 100%;
            height: 24px;
            border: 2px solid var(--spora-dark);
            padding: 0;
            background: none;
            cursor: pointer;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch {
            border: none;
        }

        .btn-group {
            display: flex;
            gap: 10px;
        }

        button {
            width: 100%;
            padding: 14px;
            background: transparent;
            border: 2px solid var(--spora-dark);
            color: var(--spora-dark);
            font-family: var(--font-mono);
            font-weight: 700;
            font-size: 11px;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            top: 0;
            left: 0;
        }

        button:hover {
            background: var(--spora-dark);
            color: var(--spora-lime);
        }

        button:active {
            top: 2px;
            left: 2px;
        }

        .btn-primary {
            background: var(--spora-lime);
            color: var(--spora-dark);
        }

        .btn-primary:hover {
            background: var(--spora-dark);
            color: var(--spora-lime);
            border-color: var(--spora-dark);
        }

        .btn-random {
            border-style: dashed;
        }

        input:disabled,
        textarea:disabled,
        select:disabled,
        button:disabled {
            pointer-events: none;
            opacity: 0.45;
        }
        
        /* Ensure render button is always enabled in locked state */
        #btnRenderPNG:not([disabled]) {
            pointer-events: auto !important;
            opacity: 1 !important;
            cursor: pointer !important;
        }

        textarea.append-only-mode {
            /* No visual indicators */
        }

        .append-only-label {
            display: none;
        }

        details {
            border: 2px solid var(--spora-dark);
            margin-bottom: 12px;
            background: transparent;
        }

        summary {
            padding: 12px;
            cursor: pointer;
            list-style: none;
            font-family: var(--font-mono);
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: transparent;
            transition: background 0.2s;
        }

        summary:hover {
            background: rgba(187, 244, 81, 0.2);
        }

        summary::after {
            content: "+";
            font-size: 14px;
        }

        details[open] summary::after {
            content: "-";
        }

        details[open] summary {
            border-bottom: 2px solid var(--spora-dark);
        }

        .folder-body {
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #canvas-container {
            flex-grow: 1;
            height: 100%;
            position: relative;
            background: #111;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }

            #ui {
                width: 100%;
                height: auto;
                max-height: 40vh;
                border-right: none;
                border-bottom: 2px solid var(--spora-dark);
            }
        }
    </style>
</head>

<body>
    <aside id="ui">
        <div style="padding-bottom: 20px; display: flex; justify-content: center">
            <a id="homeLogoLink" href="/" target="_top">
                <img src="https://res.cloudinary.com/dsy30p7gf/image/upload/v1770906020/logo-threads_dcedtk.png"
                    alt="Logo" style="width: 200px; height: 138px; display: block; object-fit: cover;" />
            </a>
        </div>
        <section>
            <h2>ARTWORK TITLE</h2>
            <div class="control-box">
                <input type="text" id="inpTitle" placeholder="Name your flora..." />
            </div>
        </section>
        <section>
            <h2>YOUR WORDS</h2>
            <div class="control-box">
                <div id="txtInp" contenteditable="true" oninput="triggerRegen(); updateCharCount();" data-placeholder="Write something meaningful..." style="resize: none; min-height: 120px; max-height: 300px; overflow-y: auto; white-space: pre-wrap; word-wrap: break-word;">Look, this is where you plant your words. Words that transform, creating life from code. These flowers take the sentiment of your verses, their shape, their rhythm, and turn them into a strange, digital bloom. As you type, the text mutates, growing into a unique form that echoes the feeling of what you just wrote.</div>
            </div>
            <div id="charCount" style="text-align: left; font-family: var(--font-mono); font-size: 10px; color: var(--spora-dark); margin-top: 4px; opacity: 0.7;"></div>
        </section>

        <section>
            <h2>VISUAL MOODS</h2>
            <div class="btn-group">
                <button onclick="applyVisualState(moodProfiles.positive)">JOY</button>
                <button onclick="applyVisualState(moodProfiles.negative)">VOID</button>
                <button onclick="applyVisualState(moodProfiles.chaos)">GLITCH</button>
            </div>
            <div class="btn-group" style="margin-bottom: 5px">
                <button onclick="applyVisualState(moodProfiles.editorial)">EDITORIAL</button>
                <button onclick="applyVisualState(moodProfiles.system)">SYSTEM</button>
            </div>
            <div class="btn-group">
                <button onclick="applyVisualState(moodProfiles.midnight)">MIDNIGHT</button>
                <button onclick="applyVisualState(moodProfiles.warning)">WARNING</button>
            </div>

            <button class="btn-random" style="margin-top: 10px" onclick="randomizeState()">
                RANDOM MUTATION
            </button>
        </section>

        <section>
            <h2>PARAMETERS</h2>

            <details open>
                <summary>GEOMETRY</summary>
                <div class="folder-body">
                    <div class="control-box">
                        <div class="row-h"><label>FONT DNA</label></div>
                        <select id="selFont" onchange="triggerVisuals()">
                            <option value="'JetBrains Mono', monospace">JetBrains Mono (Dev)</option>
                            <option value="'Inter', sans-serif">Inter (UI Standard)</option>
                            <option value="'DM Sans', sans-serif">DM Sans (Geometric)</option>
                            <option value="'Darker Grotesque', sans-serif">Darker Grotesque (Raw)</option>
                            <option value="'Cormorant Garamond', serif">Cormorant (Elegant)</option>
                            <option value="'Libre Baskerville', serif">Baskerville (Book)</option>
                            <option value="'Playfair Display', serif">Playfair Display (Fashion)</option>
                            <option value="'Gloock', serif">Gloock (Contrast)</option>
                            <option value="'BIZ UDMincho', serif">BIZ UDMincho (Mincho)</option>
                            <option value="'Space Mono', monospace">Space Mono (Tech)</option>
                            <option value="'Xanh Mono', monospace">Xanh Mono (Hybrid)</option>
                            <option value="'Syne', sans-serif">Syne (Art House)</option>
                            <option value="'BioRhyme', serif">BioRhyme (Brutalist)</option>
                            <option value="'Eczar', serif">Eczar (Spiky)</option>
                            <option value="'Grenze Gotisch', cursive">Grenze Gotisch (Dark)</option>
                        </select>
                    </div>

                    <div class="control-box">
                        <div class="row-h"><label id="lblSize">SIZE: 16px</label></div>
                        <input type="range" id="rngSize" min="10" max="80" value="16" oninput="updateUI('lblSize', 'SIZE', this.value, 'px'); triggerVisuals();" />
                    </div>

                    <div class="control-box">
                        <div class="row-h"><label id="lblScale">SCALE: 1.5x</label></div>
                        <input type="range" id="rngScale" min="0.5" max="2.5" step="0.1" value="1.5" oninput="updateUI('lblScale', 'SCALE', this.value, 'x'); triggerVisuals();" />
                    </div>
                </div>
            </details>

            <details>
                <summary>FILL & COLOR</summary>
                <div class="folder-body">
                    <div class="control-box">
                        <div class="row-h"><label>Fill Mode</label></div>
                        <select id="selFillDir" onchange="triggerVisuals()">
                            <option value="vertical">Vertical</option>
                            <option value="horizontal">Horizontal</option>
                            <option value="radial">Radial</option>
                        </select>
                    </div>
                    <div class="row-h">
                        <label>Show Fill</label>
                        <input type="checkbox" id="chkMask" />
                    </div>
                    <div class="row-h">
                        <label>Gradient Active</label>
                        <input type="checkbox" id="chkFillGradient" />
                    </div>

                    <div class="control-box" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px">
                        <input type="color" id="colMaskGradA" value="#0000ff" title="Color A" oninput="triggerVisuals()" />
                        <input type="color" id="colMaskGradB" value="#00ffea" title="Color B" oninput="triggerVisuals()" />
                    </div>

                    <div class="row-h">
                        <label>Auto-Contrast</label>
                        <input type="checkbox" id="chkAutoContrast" checked onchange="triggerVisuals()" />
                    </div>

                    <div class="control-box">
                        <div class="row-h"><label>STEM COLOR</label></div>
                        <input type="color" id="colStem" value="#15ff00" oninput="triggerVisuals()" />
                    </div>
                    <div class="control-box">
                        <div class="row-h"><label>TEXT COLOR</label></div>
                        <input type="color" id="colTextSolid" value="#ffffff" oninput="triggerVisuals()" />
                    </div>
                </div>
            </details>

            <details>
                <summary>STROKE</summary>
                <div class="folder-body">
                    <div class="row-h">
                        <label>Active</label>
                        <input type="checkbox" id="chkOutline" />
                    </div>
                    <div class="control-box">
                        <label id="lblOutlineWidth">WIDTH: 1px</label>
                        <input type="range" id="rngOutlineWidth" min="1" max="6" step="1" value="1" oninput="updateUI('lblOutlineWidth', 'WIDTH', this.value, 'px'); triggerVisuals();" />
                    </div>
                    <div class="control-box">
                        <input type="color" id="colOutlineSolid" value="#ffffff" />
                    </div>
                </div>
            </details>

            <details>
                <summary>PHYSICS & CHAOS</summary>
                <div class="folder-body">
                    <div class="control-box">
                        <div class="row-h"><label>Wind Sim</label><input type="checkbox" id="chkWind" /></div>
                        <input type="range" id="rngWind" min="0" max="2" step="0.1" value="0.5" />
                    </div>
                    <div class="control-box">
                        <div class="row-h"><label>Scramble Text</label><input type="checkbox" id="chkScramble" /></div>
                        <input type="range" id="rngScramble" min="0" max="1" step="0.05" value="0.1" />
                    </div>
                    <div class="control-box">
                        <div class="row-h"><label>Jitter Pos</label><input type="checkbox" id="chkJitter" /></div>
                        <input type="range" id="rngJitter" min="0" max="2" step="0.1" value="0.5" />
                    </div>
                    <div class="control-box">
                        <div class="row-h"><label>Pulse Text</label><input type="checkbox" id="chkPulse" /></div>
                        <input type="range" id="rngPulse" min="0" max="2" step="0.1" value="1.0" />
                    </div>
                    <div class="control-box">
                        <div class="row-h"><label>Wave Flow</label><input type="checkbox" id="chkWave" /></div>
                        <input type="range" id="rngWave" min="0" max="2" step="0.1" value="1.0" />
                    </div>
                </div>
            </details>

            <details>
                <summary>BACKGROUND</summary>
                <div class="folder-body">
                    <div class="control-box">
                        <label>MODE</label>
                        <select id="selBgMode" onchange="updateBackground(); triggerVisuals();">
                            <option value="gradient">Gradient</option>
                            <option value="solid">Solid Color</option>
                            <option value="tile">Image Pattern</option>
                            <option value="stretch">Image Stretch</option>
                        </select>
                    </div>
                    <div class="control-box">
                        <label>URL</label>
                        <input type="text" id="inpBgUrl" value="https://images.fineartamerica.com/images/artworkimages/mediumlarge/2/cosmos-flower-on-black-background-mike-hill.jpg" onchange="updateBackground()" />
                    </div>
                    <div class="control-box" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px">
                        <input type="color" id="colBgGradA" value="#0000ff" oninput="updateBackground(); triggerVisuals();" />
                        <input type="color" id="colBgGradB" value="#ffffff" oninput="updateBackground()" />
                    </div>
                    <div class="control-box">
                        <label id="lblBgAngle">ANGLE: 180deg</label>
                        <input type="range" id="rngBgAngle" min="0" max="360" value="180" oninput="updateUI('lblBgAngle', 'ANGLE', this.value, 'deg'); updateBackground();" />
                    </div>
                </div>
            </details>
        </section>

        <section style="margin-top: auto; padding-top: 25px; border-top: 2px solid var(--spora-dark);">
            <h2>SYSTEM EXPORT</h2>
            <div class="btn-group" style="margin-bottom: 12px">
                <button id="btnPublishBlossoming" class="btn-primary" onclick="submitFlora('blossoming')">PUBLISH BLOSSOMING</button>
                <button id="btnPublishSealed" class="btn-primary" onclick="submitFlora('sealed')">PUBLISH SEALED</button>
            </div>
            <button id="btnRegenerate" class="btn-primary" style="margin-bottom: 12px" onclick="generateGarden()">REGENERATE SEED</button>
            <div class="btn-group">
                <button onclick="downloadState()">SAVE JSON</button>
                <button id="btnRenderPNG" onclick="saveFullArt()">RENDER PNG</button>
            </div>
            <input type="file" id="fileInput" accept=".json" onchange="loadStateFromFile(this)" style="display: none" />
            <button style="margin-top: 10px; border-style: dotted" onclick="document.getElementById('fileInput').click()">LOAD JSON FILE</button>
            <div class="status" id="statusText" style="margin-top: 15px; font-family: var(--font-mono); font-size: 9px; text-align: center; color: var(--spora-dark); opacity: 0.6;">SYSTEM READY</div>
        </section>
    </aside>

    <div id="canvas-container"></div>

    <div id="confirmModal" class="confirm-modal-overlay" aria-hidden="true">
        <div class="confirm-modal" role="document">
            <h2 id="confirmModalTitle" class="confirm-modal-title">Leave the Laboratory?</h2>
            <p id="confirmModalDesc" class="confirm-modal-desc">If you leave the Laboratory you'll lose the current words, tweaks and generation settings for this flora.</p>
            <div class="confirm-modal-actions">
                <button id="confirmCancelBtn" type="button" class="confirm-modal-btn">STAY HERE</button>
                <button id="confirmOkBtn" type="button" class="confirm-modal-btn confirm-modal-btn-confirm">GO HOME</button>
            </div>
        </div>
    </div>

    <script>
        let flowers = [];
        let targetFlowerSet = null;
        let lastUsedSet = "daisy";
        let currentFlora = null;
        let currentUser = null;
        let lockedBaseText = "";
        let appendHandlers = null;
        let isBlossomingMode = false;

        function getQueryParam(key) {
            const params = new URLSearchParams(window.location.search);
            return params.get(key);
        }

        function setLockedState(locked) {
            const ui = document.getElementById("ui");
            if (!ui) return;
            
            if (locked) {
                ui.classList.add("is-locked");
                
                // First, disable ALL elements
                ui.querySelectorAll("input, textarea, select, button, [contenteditable]").forEach((el) => {
                    el.disabled = true;
                    if (el.hasAttribute("contenteditable")) {
                        el.setAttribute("contenteditable", "false");
                    }
                });
                
                // Then, explicitly enable ONLY the RENDER PNG button
                const renderBtn = document.getElementById("btnRenderPNG");
                if (renderBtn) {
                    renderBtn.disabled = false;
                    renderBtn.removeAttribute("disabled");
                    renderBtn.style.pointerEvents = "auto";
                    renderBtn.style.opacity = "1";
                    renderBtn.style.cursor = "pointer";
                    console.log("Render button enabled:", renderBtn);
                }
            } else {
                ui.classList.remove("is-locked");
                
                // Re-enable all elements
                ui.querySelectorAll("input, textarea, select, button, [contenteditable]").forEach((el) => {
                    el.disabled = false;
                    el.removeAttribute("disabled");
                    if (el.hasAttribute("contenteditable")) {
                        el.setAttribute("contenteditable", "true");
                    }
                });
            }
        }

        function setBlossomingMode(enabled) {
            const ui = document.getElementById("ui");
            if (!ui) return;
            
            isBlossomingMode = enabled;
            const keepEnabled = new Set(["txtInp", "btnPublishBlossoming", "btnPublishSealed", "btnRegenerate"]);

            ui.querySelectorAll("input, textarea, select, button").forEach((el) => {
                const id = el.id || "";
                if (keepEnabled.has(id)) {
                    el.disabled = false;
                    el.removeAttribute("disabled");
                } else {
                    el.disabled = enabled;
                    if (enabled) {
                        el.setAttribute("disabled", "true");
                    } else {
                        el.removeAttribute("disabled");
                    }
                }
            });
        }

        function enableAppendOnlyText(baseText) {
            const txt = document.getElementById("txtInp");
            if (!txt) return;

            lockedBaseText = baseText || "";
            
            // Ensure text ends with newline for separation
            if (lockedBaseText && !lockedBaseText.endsWith('\n')) {
                lockedBaseText += '\n';
            }
            
            // Structure the content with styled spans ONCE
            const currentText = txt.textContent;
            const newTextPortion = currentText.substring(lockedBaseText.length);
            txt.innerHTML = `<span class="base-text">${escapeHTML(lockedBaseText)}</span><span class="new-text" id="newTextSpan">${escapeHTML(newTextPortion)}</span>`;
            
            // Move cursor to end
            moveCursorToEnd(txt);

            if (appendHandlers) {
                txt.removeEventListener("beforeinput", appendHandlers.onBeforeInput);
                txt.removeEventListener("keydown", appendHandlers.onKeyDown);
                txt.removeEventListener("input", appendHandlers.onInput);
                txt.removeEventListener("paste", appendHandlers.onPaste);
                txt.removeEventListener("cut", appendHandlers.onCut);
                txt.removeEventListener("mouseup", appendHandlers.onMouseUp);
                txt.removeEventListener("click", appendHandlers.onClick);
                txt.removeEventListener("focus", appendHandlers.onFocus);
            }

            const getCursorPosition = () => {
                const selection = window.getSelection();
                if (!selection.rangeCount) return txt.textContent.length;
                
                const range = selection.getRangeAt(0);
                const preCaretRange = range.cloneRange();
                preCaretRange.selectNodeContents(txt);
                preCaretRange.setEnd(range.endContainer, range.endOffset);
                return preCaretRange.toString().length;
            };

            const onBeforeInput = (e) => {
                const cursorPos = getCursorPosition();
                
                // Prevent editing in the base text area
                if (cursorPos < lockedBaseText.length) {
                    e.preventDefault();
                    
                    // If trying to insert, append at the end
                    const newTextSpan = document.getElementById('newTextSpan');
                    if (newTextSpan && (e.inputType === 'insertText' && e.data)) {
                        newTextSpan.textContent += e.data;
                        moveCursorToEnd(txt);
                        updateCharCount();
                        triggerRegen();
                    } else if (newTextSpan && e.inputType === 'insertLineBreak') {
                        newTextSpan.textContent += '\n';
                        moveCursorToEnd(txt);
                        updateCharCount();
                        triggerRegen();
                    }
                }
            };

            const onKeyDown = (e) => {
                const cursorPos = getCursorPosition();
                
                if (cursorPos < lockedBaseText.length) {
                    const allowedKeys = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Home', 'End', 'PageUp', 'PageDown', 'Tab'];
                    const isCopy = (e.ctrlKey || e.metaKey) && (e.key === 'c' || e.key === 'C');
                    
                    if (!allowedKeys.includes(e.key) && !isCopy) {
                        e.preventDefault();
                        moveCursorToEnd(txt);
                    }
                }
            };

            const onPaste = (e) => {
                const cursorPos = getCursorPosition();
                if (cursorPos < lockedBaseText.length) {
                    e.preventDefault();
                    const pasteData = e.clipboardData.getData('text/plain');
                    const newTextSpan = document.getElementById('newTextSpan');
                    if (newTextSpan) {
                        newTextSpan.textContent += pasteData;
                        moveCursorToEnd(txt);
                        updateCharCount();
                        triggerRegen();
                    }
                }
            };

            const onCut = (e) => {
                const cursorPos = getCursorPosition();
                if (cursorPos < lockedBaseText.length) {
                    e.preventDefault();
                }
            };

            const onMouseUp = () => {
                const cursorPos = getCursorPosition();
                if (cursorPos < lockedBaseText.length) {
                    setTimeout(() => moveCursorToEnd(txt), 0);
                }
            };

            const onClick = () => {
                const cursorPos = getCursorPosition();
                if (cursorPos < lockedBaseText.length) {
                    setTimeout(() => moveCursorToEnd(txt), 0);
                }
            };

            const onInput = () => {
                // Only update char count and trigger regen, don't rebuild HTML
                updateCharCount();
                triggerRegen();
            };
            
            const onFocus = () => {
                setTimeout(() => {
                    const cursorPos = getCursorPosition();
                    if (cursorPos < lockedBaseText.length) {
                        moveCursorToEnd(txt);
                    }
                }, 0);
            };

            appendHandlers = { onBeforeInput, onKeyDown, onInput, onPaste, onCut, onMouseUp, onClick, onFocus };
            txt.addEventListener("beforeinput", onBeforeInput);
            txt.addEventListener("keydown", onKeyDown);
            txt.addEventListener("input", onInput);
            txt.addEventListener("paste", onPaste);
            txt.addEventListener("cut", onCut);
            txt.addEventListener("mouseup", onMouseUp);
            txt.addEventListener("click", onClick);
            txt.addEventListener("focus", onFocus);
        }
        
        function escapeHTML(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }
        
        function moveCursorToEnd(element) {
            const range = document.createRange();
            const selection = window.getSelection();
            range.selectNodeContents(element);
            range.collapse(false);
            selection.removeAllRanges();
            selection.addRange(range);
        }

        const maskUrls = {
            daisy: [
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636190/img-4_oqbcpb.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636194/img-3_pm6vm5.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636194/img-2_tosyul.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636193/img-1_wopfs4.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770637077/filled-1_2_vsngfl.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770637078/filled-0_2_w9rh7y.png",
            ],
            carnation: [
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636207/img-8_xeah1b.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636207/img-7_hzirh9.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636204/img-5_koy5ks.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636832/filled-4_sn6mnd.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636834/filled-3_ukp1hd.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636856/filled-2_aurbfg.png",
            ],
            orchid: [
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636219/img-12_spjimp.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636227/img-16_wvlvci.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636220/img-13_oofcme.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636849/filled-0_t10fbi.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636848/filled-10_guyxib.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636839/filled-9_qpc2dd.png",
            ],
            rose: [
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636237/img-19_dksffa.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636245/img-23_vel44w.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636238/img-18_xjxkrf.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636236/img-17_mtu34q.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636853/filled-1_a0npdc.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636836/filled-7_qcnn41.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636838/filled-8_fnbj0j.png",
            ],
        };

        let loadedAssets = {};
        let debounceTimer, visualDebounce;
        const BASE_SIZE = 280;

        function preload() {
            Object.keys(maskUrls).forEach(s => loadedAssets[s] = maskUrls[s].map(u => loadImage(u)));
        }

        function setup() {
            const cnv = createCanvas(1, 1);
            cnv.parent("canvas-container");
            pixelDensity(1);
            frameRate(30);
            updateBackground();
            setTimeout(windowResized, 0);
        }

        function forceAlpha(c) { c.setAlpha(255); return c; }

        function getContrastColor(hex) {
            if (!hex) return "#ffffff";
            const r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
            return (0.299 * r + 0.587 * g + 0.114 * b) / 255 > 0.5 ? "#000000" : "#ffffff";
        }

        function draw() {
            clear();
            const ui = id => document.getElementById(id);
            const windOn = ui("chkWind").checked, windF = parseFloat(ui("rngWind").value);
            const scrambleOn = ui("chkScramble").checked, scrambleF = parseFloat(ui("rngScramble").value);
            const jitterOn = ui("chkJitter").checked, jitterF = parseFloat(ui("rngJitter").value);
            const pulseOn = ui("chkPulse").checked, pulseF = parseFloat(ui("rngPulse").value);
            const waveOn = ui("chkWave").checked, waveF = parseFloat(ui("rngWave").value);
            const maskOn = ui("chkMask").checked, outlineOn = ui("chkOutline").checked;
            const fillGradOn = ui("chkFillGradient").checked, fillDir = ui("selFillDir").value;
            const autoContrast = ui("chkAutoContrast").checked;

            const cStem = color(ui("colStem").value);
            const cFillA = forceAlpha(color(ui("colMaskGradA").value)), cFillB = forceAlpha(color(ui("colMaskGradB").value));
            const cOutline = forceAlpha(color(ui("colOutlineSolid").value));

            if (autoContrast) {
                const ref = maskOn ? ui("colMaskGradA").value : ui("colBgGradA").value;
                ui("colTextSolid").value = getContrastColor(ref);
            }
            const cText = color(ui("colTextSolid").value);

            textFont(ui("selFont").value);
            const time = millis() * 0.001;

            flowers.forEach((f, i) => {
                let swayX = 0, swayR = 0, bend = f.bend;
                if (windOn) {
                    const n = sin(time + i + f.x * 0.01) + sin(time * 2 + i);
                    bend += n * 35 * windF; swayR = n * 0.05 * windF; swayX = n * 35 * windF;
                }

                let dBr = constrain(map(f.ty, height * 0.1, height * 0.8, 0.3, 1.0), 0.3, 1.0);
                stroke(red(cStem) * dBr, green(cStem) * dBr, blue(cStem) * dBr);
                strokeWeight(lerp(5, 15, f.h / height)); noFill();

                const p0x = f.x, p0y = height + 10, p2x = f.tx + swayX, p2y = f.ty;
                const p1x = p0x + bend * 0.5, p1y = p2y + (p0y - p2y) * 0.4;
                beginShape();
                for (let t = 0; t <= 1; t += 0.05) {
                    let mt = 1 - t;
                    vertex(mt * mt * p0x + 2 * mt * t * p1x + t * t * p2x, mt * mt * p0y + 2 * mt * t * p1y + t * t * p2y);
                }
                endShape();

                push(); translate(p2x, p2y); rotate(swayR);
                if (pulseOn) scale(1.0 + (sin(time * 1.2 + i) * 0.7 + sin(time * 0.6 + i * 1.5) * 0.3) * (0.04 * pulseF));

                if (maskOn && f.graphic) {
                    let fillT = 0;
                    if (fillGradOn) {
                        if (fillDir === "vertical") fillT = constrain(map(f.ty, 0, height, 0, 1), 0, 1);
                        else if (fillDir === "horizontal") fillT = constrain(map(f.tx, 0, width, 0, 1), 0, 1);
                        else { let d = dist(f.tx, f.ty, width / 2, height / 2); fillT = constrain(map(d, 0, dist(0, 0, width / 2, height / 2), 0, 1), 0, 1); }
                    }
                    tint(fillGradOn ? lerpColor(cFillA, cFillB, fillT) : cFillA);
                    imageMode(CENTER); noStroke(); image(f.graphic, 0, 0); noTint();
                }

                if (outlineOn && f.graphicOutline) { tint(cOutline); imageMode(CENTER); image(f.graphicOutline, 0, 0); noTint(); }

                noStroke(); textSize(f.fontSize); textAlign(CENTER, CENTER); fill(cText);
                f.points.forEach((p, idx) => {
                    let cIdx = idx % f.chars.length, dx = p.x, dy = p.y;
                    if (scrambleOn && scrambleF > 0 && noise(idx * 0.2, time * 2) > (1 - scrambleF * 0.8)) {
                        cIdx = (cIdx + floor(noise(idx, floor(time * 5)) * f.chars.length)) % f.chars.length;
                    }
                    if (jitterOn) {
                        let cid = floor(idx / floor(constrain(map(f.fontSize, 10, 80, 10, 3), 1, 10)));
                        let amp = jitterF * 5 * constrain(map(f.fontSize, 10, 80, 0.5, 2.5), 0.5, 3.0);
                        dx += map(noise(cid * 0.1, floor(time * 8) * 0.5), 0, 1, -amp, amp);
                        dy += map(noise(cid * 0.1 + 500, floor(time * 8) * 0.5), 0, 1, -amp, amp);
                    }
                    if (waveOn) dx += sin(time * 4 + p.y * 0.05) * (3 * waveF);
                    text(f.chars[cIdx], dx, dy);
                });
                pop();
            });
        }

        function generateGarden() {
            flowers.forEach(f => { f.graphic.remove(); if (f.graphicOutline) f.graphicOutline.remove(); });
            flowers = [];
            const txt = document.getElementById("txtInp").textContent.trim(); if (!txt) return;
            const bS = parseInt(document.getElementById("rngSize").value), sS = parseFloat(document.getElementById("rngScale").value), oW = parseInt(document.getElementById("rngOutlineWidth").value);
            const sets = Object.keys(loadedAssets), activeS = targetFlowerSet || sets[floor(random(sets.length))];
            lastUsedSet = activeS; const imgs = loadedAssets[activeS];
            document.getElementById("statusText").innerText = `SET: ${activeS.toUpperCase()} | CALC...`;
            const words = txt.split(/\s+/), count = constrain(ceil(words.length / 12), 2, 20);
            let dF = count > 5 ? map(count, 5, 20, 1.0, 0.55) : 1.0, eS = sS * dF;
            let chunks = [];
            if (words.length < count) for (let i = 0; i < count; i++) chunks.push(txt.split(""));
            else { let wPF = ceil(words.length / count); for (let i = 0; i < count; i++) chunks.push(words.slice(i * wPF, (i + 1) * wPF).join(" ").split("")); }
            const maxW = min(width, 1400);
            for (let i = 0; i < count; i++) {
                let best = null, att = 0;
                while (!best && att++ < 100) {
                    const sc = eS * random(0.9, 1.1), rad = (BASE_SIZE * sc) / 2 + 5, spr = maxW * map(eS, 0.5, 2.5, 0.35, 0.5);
                    const tx = width / 2 + random(-spr, spr), ty = height - height * random(0.15, map(i / (count - 1 || 1), 0, 1, 0.4, 0.85));
                    if (flowers.some(f => dist(tx, ty, f.tx, f.ty) < rad + f.radius)) continue;
                    const img = random(imgs), fz = bS * random(0.9, 1.1), data = processImage(img, fz, sc, oW);
                    best = { x: width / 2, tx, ty, h: height - ty, bend: random(-100, 100), chars: chunks[i] || chunks[0], points: data.points, graphic: data.pg, graphicOutline: data.pgOutline, source: img, fontSize: fz, radius: rad, relScale: sc / sS, relFont: fz / bS };
                }
                if (best) flowers.push(best);
            }
            flowers.sort((a, b) => a.ty - b.ty);
            document.getElementById("statusText").innerText = `READY | BLOOMS: ${flowers.length}`;
            
            if (isBlossomingMode && lockedBaseText) {
                setTimeout(() => {
                    setBlossomingMode(true);
                    enableAppendOnlyText(lockedBaseText);
                }, 10);
            }
        }

        function updateVisuals() {
            const bS = parseInt(document.getElementById("rngSize").value), sS = parseFloat(document.getElementById("rngScale").value), oW = parseInt(document.getElementById("rngOutlineWidth").value);
            const dF = flowers.length > 5 ? map(flowers.length, 5, 20, 1.0, 0.55) : 1.0, eS = sS * dF;
            flowers.forEach(f => {
                const nSc = eS * f.relScale, nSi = bS * f.relFont;
                f.graphic.remove(); if (f.graphicOutline) f.graphicOutline.remove();
                const d = processImage(f.source, nSi, nSc, oW);
                f.points = d.points; f.graphic = d.pg; f.graphicOutline = d.pgOutline; f.fontSize = nSi; f.radius = (BASE_SIZE * nSc) / 2 + 5;
            });
            
            if (isBlossomingMode) {
                setTimeout(() => setBlossomingMode(true), 10);
            }
        }

        function processImage(img, fz, sc, ow) {
            const dim = ceil(BASE_SIZE * sc), pg = createGraphics(dim, dim), pgo = createGraphics(dim, dim);
            const asp = img.width / img.height, w = asp >= 1 ? dim : dim * asp, h = asp >= 1 ? dim / asp : dim;
            pg.image(img, (dim - w) / 2, (dim - h) / 2, w, h); pg.loadPixels();
            const pts = [], step = max(fz * constrain(map(fz, 10, 80, 1.0, 0.1), 0.6, 1.0), 2);
            for (let y = 0; y < dim; y += step) for (let x = 0; x < dim; x += step) {
                const i = (floor(x) + floor(y) * dim) * 4;
                if (i < pg.pixels.length && pg.pixels[i + 3] > 20) pts.push({ x: x - dim / 2, y: y - dim / 2 });
            }
            const pW = pg.width; pgo.stroke(255); pgo.strokeWeight(ow); pgo.noFill();
            for (let y = 1; y < dim - 1; y++) for (let x = 1; x < dim - 1; x++) {
                const i = (x + y * pW) * 4;
                if (pg.pixels[i + 3] > 0 && (pg.pixels[i - 1] === 0 || pg.pixels[i + 7] === 0 || pg.pixels[i - pW * 4 + 3] === 0 || pg.pixels[i + pW * 4 + 3] === 0)) pgo.point(x, y);
            }
            for (let i = 0; i < pg.pixels.length; i += 4) { if (pg.pixels[i + 3] > 20) { pg.pixels[i] = pg.pixels[i + 1] = pg.pixels[i + 2] = 255; pg.pixels[i + 3] = 255; } else pg.pixels[i + 3] = 0; }
            pg.updatePixels(); return { points: pts, pg, pgOutline: pgo };
        }

        function updateBackground() {
            const ui = id => document.getElementById(id), mode = ui("selBgMode").value, cA = ui("colBgGradA").value, cB = ui("colBgGradB").value, ang = ui("rngBgAngle").value, url = ui("inpBgUrl").value, cont = ui("canvas-container");
            cont.style.background = mode === "solid" ? cA : mode === "gradient" ? `linear-gradient(${ang}deg, ${cA}, ${cB})` : `url('${url}')`;
            cont.style.backgroundRepeat = mode === "tile" ? "repeat" : "no-repeat";
            cont.style.backgroundSize = mode === "tile" ? "100px 100px" : mode === "stretch" ? "100% 100%" : "auto";
        }

        function triggerRegen() { clearTimeout(debounceTimer); debounceTimer = setTimeout(generateGarden, 400); }
        function triggerVisuals() { clearTimeout(visualDebounce); visualDebounce = setTimeout(updateVisuals, 100); }
        function updateUI(id, t, v, u) { document.getElementById(id).innerText = `${t}: ${v}${u}`; }
        function updateCharCount() { const t = document.getElementById("txtInp"); document.getElementById("charCount").textContent = t.textContent.length + " characters"; }

        function saveFullArt() {
            const s = document.getElementById("statusText"); s.innerText = "RENDERING...";
            html2canvas(document.getElementById("canvas-container"), { scale: 2, useCORS: true }).then(c => {
                const l = document.createElement("a"); l.download = "spora_" + Date.now() + ".png"; l.href = c.toDataURL(); l.click(); s.innerText = "DONE";
            });
        }

        function collectState() {
            return {
                title: document.getElementById("inpTitle").value,
                text: document.getElementById("txtInp").textContent,
                flowerSet: lastUsedSet,
                wind: { active: document.getElementById("chkWind").checked, strength: parseFloat(document.getElementById("rngWind").value) },
                chaos: {
                    scramble: document.getElementById("chkScramble").checked,
                    scrambleForce: parseFloat(document.getElementById("rngScramble").value),
                    jitter: document.getElementById("rngJitter").value,
                    pulse: document.getElementById("rngPulse").value,
                    wave: document.getElementById("rngWave").value,
                },
                colors: {
                    maskA: document.getElementById("colMaskGradA").value,
                    maskB: document.getElementById("colMaskGradB").value,
                    stem: document.getElementById("colStem").value,
                    text: document.getElementById("colTextSolid").value,
                    bgA: document.getElementById("colBgGradA").value,
                    bgB: document.getElementById("colBgGradB").value,
                    auto: document.getElementById("chkAutoContrast").checked,
                },
                geometry: {
                    scale: parseFloat(document.getElementById("rngScale").value),
                    fontSize: parseInt(document.getElementById("rngSize").value),
                    font: document.getElementById("selFont").value,
                },
                style: {
                    mask: document.getElementById("chkMask").checked,
                    grad: document.getElementById("chkFillGradient").checked,
                    outline: document.getElementById("chkOutline").checked,
                    outlineW: document.getElementById("rngOutlineWidth").value,
                },
                background: {
                    mode: document.getElementById("selBgMode").value,
                    angle: document.getElementById("rngBgAngle").value,
                },
            };
        }

        function downloadState() {
            const s = collectState();
            const a = document.createElement("a");
            a.href = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(s, null, 2));
            a.download = "spora_state.json";
            a.click();
        }

        async function submitFlora(status) {
            const s = document.getElementById("statusText");
            const token = localStorage.getItem("spora_token");
            const state = collectState();

            if (!token) {
                s.innerText = "LOGIN REQUIRED";
                return;
            }

            if (!state.text || state.text.trim().length < 10) {
                s.innerText = "ADD MORE TEXT";
                return;
            }

            s.innerText = "SAVING...";
            const apiBase = window.location.hostname === "localhost"
                ? "http://localhost:4000/api"
                : "/api";

            if (!currentUser) {
                try {
                    const meRes = await fetch(apiBase + "/auth/me", {
                        headers: { "Authorization": "Bearer " + token },
                    });
                    if (meRes.ok) currentUser = await meRes.json();
                } catch (err) {
                    currentUser = null;
                }
            }

            const lineageUsernames = new Set();
            if (currentUser && currentUser.username) lineageUsernames.add(currentUser.username);
            if (currentFlora && Array.isArray(currentFlora.coAuthors)) {
                currentFlora.coAuthors.forEach((a) => a && a.username && lineageUsernames.add(a.username));
            }
            if (currentFlora && currentFlora.authorUsername) lineageUsernames.add(currentFlora.authorUsername);

            const payload = {
                title: state.title || "Untitled Flora",
                text: state.text,
                status: status,
                generative: {
                    labState: {
                        ...state,
                        lineageUsernames: Array.from(lineageUsernames),
                    },
                },
            };

            if (currentFlora && currentFlora.status === "blossoming") {
                const baseGeneration = currentFlora.lineage && typeof currentFlora.lineage.generation === "number"
                    ? currentFlora.lineage.generation
                    : 0;
                const rootId = currentFlora.lineage && currentFlora.lineage.rootFloraId
                    ? currentFlora.lineage.rootFloraId
                    : currentFlora._id;

                const priorCoAuthors = Array.isArray(currentFlora.coAuthors) ? currentFlora.coAuthors : [];
                const usernames = new Set();
                priorCoAuthors.forEach((a) => a && a.username && usernames.add(a.username));
                if (currentFlora.authorUsername) usernames.add(currentFlora.authorUsername);
                if (currentUser && currentUser.username) usernames.delete(currentUser.username);

                payload.lineage = {
                    generation: baseGeneration + 1,
                    parentFloraId: currentFlora._id,
                    rootFloraId: rootId,
                };

                payload.coAuthors = Array.from(usernames).map((username) => ({
                    username,
                    generation: baseGeneration,
                    contributedAt: new Date().toISOString(),
                    isAnonymized: false,
                }));
            }

            try {
                const res = await fetch(apiBase + "/floras", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": "Bearer " + token,
                    },
                    body: JSON.stringify(payload),
                });

                const data = await res.json().catch(() => ({}));
                if (!res.ok) {
                    s.innerText = (data && data.error) ? data.error.toUpperCase() : "SAVE FAILED";
                    return;
                }

                s.innerText = status === "sealed" ? "SEALED" : "BLOSSOMING";
                setTimeout(() => {
                    window.open(`/flora/${data._id}`, "_blank");
                }, 800);
            } catch (err) {
                s.innerText = "NETWORK ERROR";
            }
        }

        function loadStateFromFile(i) {
            const f = i.files[0]; if (!f) return; const r = new FileReader();
            r.onload = e => applyVisualState(JSON.parse(e.target.result)); r.readAsText(f);
        }

        async function loadFloraPreview() {
            const floraId = getQueryParam("floraId");
            if (!floraId) return;

            const statusEl = document.getElementById("statusText");
            statusEl.innerText = "LOADING FLORA...";

            const apiBase = window.location.hostname === "localhost"
                ? "http://localhost:4000/api"
                : "/api";

            try {
                const res = await fetch(apiBase + "/floras/" + floraId);
                const flora = await res.json().catch(() => null);

                if (!res.ok || !flora) {
                    statusEl.innerText = "PREVIEW FAILED";
                    return;
                }

                const labState = flora.generative && flora.generative.labState
                    ? flora.generative.labState
                    : null;

                currentFlora = flora;

                if (flora.status === "sealed") {
                    setLockedState(true);
                } else if (flora.status === "blossoming") {
                    isBlossomingMode = true;
                    lockedBaseText = flora.text || "";
                }

                if (labState) {
                    applyVisualState(labState);
                } else {
                    document.getElementById("inpTitle").value = flora.title || "Untitled Flora";
                    document.getElementById("txtInp").textContent = flora.text || "";
                    generateGarden();
                }

                if (flora.status === "sealed") {
                    statusEl.innerText = "PREVIEW LOCKED";
                } else if (flora.status === "blossoming") {
                    setLockedState(false);
                    setBlossomingMode(true);
                    enableAppendOnlyText(flora.text || "");
                    statusEl.innerText = "BLOSSOMING MODE";
                } else {
                    setLockedState(false);
                    statusEl.innerText = "PREVIEW READY";
                }
            } catch (err) {
                statusEl.innerText = "PREVIEW ERROR";
            }
        }

        const moodProfiles = {
            positive: { flowerSet: "daisy", wind: { active: true, strength: 0.2 }, chaos: { pulse: 0.3, wave: 0.4 }, colors: { maskA: "#CCFF00", maskB: "#FFFFFF", stem: "#00FF00", bgA: "#0000FF", bgB: "#CCFF00", auto: true }, geometry: { scale: 1.1, fontSize: 18, font: "'Cormorant Garamond', serif" }, style: { mask: true, grad: false, outline: true, outlineW: 2 } },
            negative: { flowerSet: "rose", wind: { active: true, strength: 0.1 }, chaos: { jitter: 0.2, pulse: 0.8 }, colors: { maskA: "#000000", maskB: "#FF0000", stem: "#330000", bgA: "#FF0000", bgB: "#000000", auto: true }, geometry: { scale: 0.8, fontSize: 12, font: "'Grenze Gotisch', cursive" }, style: { mask: true, grad: true, outline: true, outlineW: 1 } },
            chaos: { flowerSet: "carnation", wind: { active: true, strength: 2.0 }, chaos: { scramble: true, scrambleForce: 0.8, jitter: 1.5, pulse: 1.2, wave: 1.8 }, colors: { maskA: "#FF00FF", maskB: "#00FF00", stem: "#00FF00", bgA: "#1a1a1a", bgB: "#330033", auto: true }, geometry: { scale: 2, fontSize: 55, font: "'Space Mono', monospace" }, style: { mask: false, grad: false, outline: true, outlineW: 4 } },
            editorial: { flowerSet: "rose", wind: { active: true, strength: 0.15 }, chaos: { wave: 0.2 }, colors: { maskA: "#D90429", maskB: "#FFCAD4", stem: "#2B2D42", bgA: "#F2F0E9", bgB: "#F2F0E9", auto: true }, geometry: { scale: 1.0, fontSize: 24, font: "'Playfair Display', serif" }, style: { mask: true, grad: true, outline: true, outlineW: 1 } },
            system: { flowerSet: "daisy", wind: { active: true, strength: 2 }, chaos: { scramble: true, scrambleForce: 0.4, jitter: 0.5, wave: 1.2 }, colors: { maskA: "#bbf451", maskB: "#ffffff", stem: "#e6e6e6", bgA: "#262626", bgB: "#262626", auto: true }, geometry: { scale: 1.2, fontSize: 16, font: "'JetBrains Mono', monospace" }, style: { mask: true, grad: false, outline: true, outlineW: 2 } },
            midnight: { flowerSet: "orchid", wind: { active: true, strength: 0.5 }, chaos: { jitter: 0.3, pulse: 0.5, wave: 0.8 }, colors: { maskA: "#4361EE", maskB: "#4CC9F0", stem: "#4CC9F0", bgA: "#050505", bgB: "#101020", auto: true }, geometry: { scale: 1.4, fontSize: 32, font: "'Syne', sans-serif" }, style: { mask: true, grad: true, outline: false, outlineW: 0 } },
            warning: { flowerSet: "carnation", wind: { active: false, strength: 0 }, chaos: { pulse: 1.5 }, colors: { maskA: "#000000", maskB: "#262626", stem: "#000000", bgA: "#FF5400", bgB: "#FF5400", auto: true }, geometry: { scale: 1.8, fontSize: 60, font: "'BioRhyme', serif" }, style: { mask: false, grad: false, outline: true, outlineW: 3 } }
        };

        function randomizeState() {
            const rC = () => "#" + floor(random(16777215)).toString(16).padStart(6, "0");
            const f = ["'Playfair Display', serif", "'Cormorant Garamond', serif", "'Inter', sans-serif", "'JetBrains Mono', monospace", "'Syne', sans-serif", "'BioRhyme', serif"];
            applyVisualState({
                flowerSet: random(Object.keys(maskUrls)), wind: { active: random() > 0.5, strength: random(2) },
                chaos: { scramble: random() > 0.8, scrambleForce: random(), jitter: random(2), pulse: random(1.5), wave: random(1.5) },
                colors: { maskA: rC(), maskB: rC(), stem: rC(), bgA: rC(), bgB: rC(), auto: true },
                geometry: { scale: random(0.5, 2.5), fontSize: random(10, 70), font: random(f) },
                style: { mask: random() > 0.2, grad: random() > 0.5, outline: random() > 0.3, outlineW: floor(random(6)) + 1 },
                background: { mode: random(["solid", "gradient"]), angle: random(360) }
            });
        }

        function applyVisualState(s) {
            const ui = id => document.getElementById(id);
            if (s.title) ui("inpTitle").value = s.title; 
            if (s.text) ui("txtInp").textContent = s.text;
            targetFlowerSet = s.flowerSet; ui("chkWind").checked = s.wind.active; ui("rngWind").value = s.wind.strength;
            ui("chkScramble").checked = s.chaos.scramble; ui("rngScramble").value = s.chaos.scrambleForce || 0.1;
            ui("rngJitter").value = s.chaos.jitter || 0.5; ui("rngPulse").value = s.chaos.pulse || 1.0; ui("rngWave").value = s.chaos.wave || 1.0;
            ui("colMaskGradA").value = s.colors.maskA; ui("colMaskGradB").value = s.colors.maskB; ui("colStem").value = s.colors.stem;
            ui("colBgGradA").value = s.colors.bgA; ui("colBgGradB").value = s.colors.bgB; ui("chkAutoContrast").checked = s.colors.auto;
            if (s.colors.text && !s.colors.auto) ui("colTextSolid").value = s.colors.text;
            ui("chkMask").checked = s.style.mask; ui("chkFillGradient").checked = s.style.grad;
            ui("chkOutline").checked = s.style.outline; ui("rngOutlineWidth").value = s.style.outlineW;
            ui("rngScale").value = s.geometry.scale; ui("rngSize").value = s.geometry.fontSize; ui("selFont").value = s.geometry.font;
            if (s.background) { ui("selBgMode").value = s.background.mode; ui("rngBgAngle").value = s.background.angle; }
            updateBackground(); updateUI("lblScale", "SCALE", s.geometry.scale, "x"); updateUI("lblSize", "SIZE", s.geometry.fontSize, "px"); generateGarden();
            
            if (isBlossomingMode) {
                setBlossomingMode(true);
            }
        }

        function windowResized() { const c = document.getElementById("canvas-container"); resizeCanvas(c.clientWidth, c.clientHeight); generateGarden(); }
        window.addEventListener("DOMContentLoaded", () => {
            updateCharCount();
            loadFloraPreview();
        });
    </script>
</body>
</html>