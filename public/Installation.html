<!DOCTYPE html>
<html lang="en" class="hide-scrollbar">

<head>
    <meta charset="UTF-8">
    <title>SPORA LABORATORY</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=BIZ+UDMincho&family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        :root {
            --spora-bg-ui: #e6e6e6;
            --spora-dark: #262626;
            --spora-lime: #bbf451;
            --spora-white: #ffffff;
            --font-main: 'BIZ UDMincho', serif;
            --font-mono: 'Jetbrains Mono', monospace;
        }

        ::selection {
            background: var(--spora-lime);
            color: var(--spora-dark);
        }

        body {
            margin: 0;
            background: #000;
            color: var(--spora-dark);
            font-family: var(--font-main);
            height: 100dvh;
            overflow: hidden;
            display: flex;
        }

        #ui {
            width: 24vw;
            min-width: 320px;
            height: 100%;
            background: var(--spora-bg-ui);
            border-right: 2px solid var(--spora-dark);
            padding: 30px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 28px;
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 10;
        }

        #ui::-webkit-scrollbar { width: 0px; background: transparent; }

        h2 {
            margin: 0 0 10px 0;
            font-family: var(--font-mono);
            font-size: 11px;
            color: var(--spora-dark);
            text-transform: uppercase;
            letter-spacing: 0.25em;
            font-weight: 700;
        }

        section {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-box {
            border: 2px solid var(--spora-dark);
            background: transparent;
            padding: 10px;
            transition: all 0.2s ease;
        }
        
        .control-box:focus-within {
            border-color: var(--spora-dark);
            box-shadow: 4px 4px 0px var(--spora-lime);
        }

        .row-h {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        label {
            font-family: var(--font-mono);
            font-size: 10px;
            color: var(--spora-dark);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-weight: 700;
        }

        textarea, input[type=text] {
            width: 100%;
            background: transparent;
            border: none;
            color: var(--spora-dark);
            font-family: var(--font-main);
            font-size: 13px;
            line-height: 1.5;
            outline: none;
            resize: none;
            padding: 0;
            margin: 0;
            font-weight: 400;
        }
        
        textarea { height: 100px; }
        textarea::placeholder { color: #888; opacity: 1; font-style: italic; }

        select {
            width: 100%;
            background: transparent;
            border: none;
            color: var(--spora-dark);
            font-family: var(--font-mono);
            font-size: 11px;
            text-transform: uppercase;
            cursor: pointer;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23262626' stroke-width='2' stroke-linecap='square' stroke-linejoin='arcs'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 0 center;
            background-size: 16px;
        }

        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
            margin: 10px 0;
        }
        
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 2px;
            background: var(--spora-dark);
            border: none;
        }
        
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 14px;
            width: 14px;
            background: var(--spora-dark);
            border: 2px solid var(--spora-dark);
            margin-top: -6px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        input[type=range]:hover::-webkit-slider-thumb {
            background: var(--spora-lime);
        }

        input[type=checkbox] {
            appearance: none;
            width: 16px;
            height: 16px;
            border: 2px solid var(--spora-dark);
            background: transparent;
            cursor: pointer;
            position: relative;
            margin: 0;
        }
        
        input[type=checkbox]:checked {
            background: var(--spora-lime);
            box-shadow: inset 0 0 0 2px var(--spora-dark); 
        }

        input[type=color] {
            width: 100%;
            height: 24px;
            border: 2px solid var(--spora-dark);
            padding: 0;
            background: none;
            cursor: pointer;
        }
        input[type=color]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type=color]::-webkit-color-swatch { border: none; }

        .btn-group {
            display: flex;
            gap: 10px;
        }

        button {
            width: 100%;
            padding: 14px;
            background: transparent;
            border: 2px solid var(--spora-dark);
            color: var(--spora-dark);
            font-family: var(--font-mono);
            font-weight: 700;
            font-size: 11px;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            top: 0;
            left: 0;
        }

        button:hover {
            background: var(--spora-dark);
            color: var(--spora-lime);
        }
        
        button:active {
            top: 2px;
            left: 2px;
        }
        
        .btn-primary {
            background: var(--spora-lime);
            color: var(--spora-dark);
        }
        .btn-primary:hover {
            background: var(--spora-dark);
            color: var(--spora-lime);
            border-color: var(--spora-dark);
        }
        
        .btn-random {
            border-style: dashed;
        }

        details {
            border: 2px solid var(--spora-dark);
            margin-bottom: 12px;
            background: transparent;
        }
        
        summary {
            padding: 12px;
            cursor: pointer;
            list-style: none;
            font-family: var(--font-mono);
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: transparent;
            transition: background 0.2s;
        }
        
        summary:hover {
            background: rgba(187, 244, 81, 0.2);
        }

        summary::after { content: "+"; font-size: 14px; }
        details[open] summary::after { content: "-"; }
        details[open] summary { border-bottom: 2px solid var(--spora-dark); }
        
        .folder-body { padding: 15px; display: flex; flex-direction: column; gap: 15px; }

        #canvas-container {
            flex-grow: 1;
            height: 100%;
            position: relative;
            background: #111;
            overflow: hidden;
            display: flex; 
            align-items: center;
            justify-content: center;
        }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }

        @media (max-width: 768px) {
            body { flex-direction: column; }
            #ui { width: 100%; height: auto; max-height: 40vh; border-right: none; border-bottom: 2px solid var(--spora-dark); }
        }
    </style>
</head>

<body>

    <aside id="ui">
        <div style="border-bottom: 2px solid var(--spora-dark); padding-bottom: 20px; display: flex; justify-content: center;">
            <img src="https://res.cloudinary.com/dsy30p7gf/image/upload/v1770896818/Ready4_b6iujg_e_sharpen_w7vgiw_c_pad_w_200_guj4yk.webp" alt="Logo" style="width: 200px; height: 138px; display: block; object-fit: cover;;">
        </div>

        <section>
            <h2>YOUR WORDS</h2>
            <div class="control-box">
                <textarea id="txtInp" oninput="triggerRegen()" placeholder="Write something meaningful...">Self-hatred grows in me like cancer. I can't locate its whereabouts but it's feasting on its host.</textarea>
            </div>
        </section>

        <section>
            <h2>EMOTIONAL STATE</h2>
            <div class="btn-group">
                <button onclick="applyVisualState(moodProfiles.positive)">JOY</button>
                <button onclick="applyVisualState(moodProfiles.negative)">VOID</button>
                <button onclick="applyVisualState(moodProfiles.chaos)">GLITCH</button>
            </div>
            <button class="btn-random" style="margin-top:5px;" onclick="randomizeState()">RANDOM MUTATION</button>
        </section>

        <section>
            <h2>PARAMETERS</h2>
            
            <details open>
                <summary>GEOMETRY</summary>
                <div class="folder-body">
                    <div class="control-box">
                        <div class="row-h"><label>FONT FAMILY</label></div>
                        <select id="selFont" onchange="triggerVisuals()">
                            <option value="Arial">System Sans</option>
                            <option value="Inter">Inter (Modern)</option>
                            <option value="Playfair Display">Playfair (Serif)</option>
                            <option value="Courier Prime">Courier (Code)</option>
                            <option value="UnifrakturMaguntia">Unifraktur (Gothic)</option>
                        </select>
                    </div>
                    
                    <div class="control-box">
                         <div class="row-h">
                            <label id="lblSize">SIZE: 16px</label>
                        </div>
                        <input type="range" id="rngSize" min="10" max="80" value="16" oninput="updateUI('lblSize', 'SIZE', this.value, 'px'); triggerVisuals();">
                    </div>

                    <div class="control-box">
                        <div class="row-h">
                           <label id="lblScale">SCALE: 1.5x</label>
                       </div>
                       <input type="range" id="rngScale" min="0.5" max="2.5" step="0.1" value="1.5" oninput="updateUI('lblScale', 'SCALE', this.value, 'x'); triggerVisuals();">
                   </div>
                </div>
            </details>

            <details>
                <summary>FILL & COLOR</summary>
                <div class="folder-body">
                    <div class="control-box">
                        <div class="row-h"><label>Fill Mode</label></div>
                        <select id="selFillDir" onchange="triggerVisuals()">
                            <option value="vertical">Vertical</option>
                            <option value="horizontal">Horizontal</option>
                            <option value="radial">Radial</option>
                        </select>
                    </div>
                    <div class="row-h">
                        <label>Show Fill</label>
                        <input type="checkbox" id="chkMask">
                    </div>
                    <div class="row-h">
                        <label>Gradient Active</label>
                        <input type="checkbox" id="chkFillGradient">
                    </div>
                    
                    <div class="control-box" style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
                        <input type="color" id="colMaskGradA" value="#0000ff" title="Color A">
                        <input type="color" id="colMaskGradB" value="#00ffea" title="Color B">
                    </div>
                </div>
            </details>

            <details>
                <summary>STROKE</summary>
                <div class="folder-body">
                    <div class="row-h">
                        <label>Active</label>
                        <input type="checkbox" id="chkOutline">
                    </div>
                    <div class="control-box">
                        <label id="lblOutlineWidth">WIDTH: 1px</label>
                        <input type="range" id="rngOutlineWidth" min="1" max="6" step="1" value="1" oninput="updateUI('lblOutlineWidth', 'WIDTH', this.value, 'px'); triggerVisuals();">
                    </div>
                    <div class="control-box">
                        <input type="color" id="colOutlineSolid" value="#ffffff">
                    </div>
                </div>
            </details>

            <details>
                <summary>PHYSICS & CHAOS</summary>
                <div class="folder-body">
                    <div class="row-h">
                        <label>Wind Sim</label>
                        <input type="checkbox" id="chkWind">
                    </div>
                    <div class="control-box">
                        <label id="lblWind">FORCE: 0.5</label>
                        <input type="range" id="rngWind" min="0" max="2" step="0.1" value="0.5" oninput="updateUI('lblWind', 'FORCE', this.value, '')">
                    </div>
                    <div class="row-h" style="border-left: 4px solid var(--spora-lime); padding-left: 10px;">
                        <label>Scramble Text</label>
                        <input type="checkbox" id="chkScramble">
                    </div>
                    <div class="row-h" style="border-left: 4px solid var(--spora-lime); padding-left: 10px;">
                        <label>Jitter Pos</label>
                        <input type="checkbox" id="chkJitter">
                    </div>
                </div>
            </details>

            <details>
                <summary>BACKGROUND</summary>
                <div class="folder-body">
                    <div class="control-box">
                        <label>MODE</label>
                        <select id="selBgMode" onchange="updateBackground()">
                            <option value="gradient">Gradient</option>
                            <option value="solid">Solid Color</option>
                            <option value="tile">Image Pattern</option>
                            <option value="stretch">Image Stretch</option>
                        </select>
                    </div>
                    <div class="control-box">
                        <label>URL</label>
                        <input type="text" id="inpBgUrl" value="https://images.fineartamerica.com/images/artworkimages/mediumlarge/2/cosmos-flower-on-black-background-mike-hill.jpg" onchange="updateBackground()">
                    </div>
                    <div class="control-box">
                        <label id="lblBgStretchY">V-STRETCH: 100%</label>
                        <input type="range" id="rngBgStretchY" min="100" max="300" value="100" oninput="updateUI('lblBgStretchY', 'V-STRETCH', this.value, '%'); updateBackground()">
                    </div>
                    <div class="control-box" style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
                        <input type="color" id="colBgGradA" value="#0000ff" oninput="updateBackground()">
                        <input type="color" id="colBgGradB" value="#ffffff" oninput="updateBackground()">
                    </div>
                    <div class="control-box">
                        <label id="lblBgAngle">ANGLE: 180deg</label>
                        <input type="range" id="rngBgAngle" min="0" max="360" value="180" oninput="updateUI('lblBgAngle', 'ANGLE', this.value, 'deg'); updateBackground()">
                    </div>
                </div>
            </details>
        </section>

        <input type="hidden" id="colStem" value="#15ff00">
        <input type="hidden" id="colTextSolid" value="#ffffff">

        <section style="margin-top:auto; padding-top:25px; border-top: 2px solid var(--spora-dark);">
            <h2>SYSTEM EXPORT</h2>
            <button class="btn-primary" style="margin-bottom:12px;" onclick="generateGarden()">REGENERATE SEED</button>
            <div class="btn-group">
                <button onclick="downloadState()">SAVE JSON</button>
                <button onclick="saveFullArt()">RENDER PNG</button>
            </div>
            
            <input type="file" id="fileInput" accept=".json" onchange="loadStateFromFile(this)" style="display:none;">
            <button style="margin-top:10px; border-style: dotted;" onclick="document.getElementById('fileInput').click()">LOAD JSON FILE</button>

            <div class="status" id="statusText" style="margin-top:15px; font-family:var(--font-mono); font-size:9px; text-align:center; color:var(--spora-dark); opacity:0.6;">SYSTEM READY</div>
        </section>
    </aside>

    <div id="canvas-container"></div>

    <script>
        let flowers = [];
        let targetFlowerSet = null; 
        let lastUsedSet = 'daisy';

        const maskUrls = {
            daisy: [
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636190/img-4_oqbcpb.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636194/img-3_pm6vm5.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636194/img-2_tosyul.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636193/img-1_wopfs4.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770637077/filled-1_2_vsngfl.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770637078/filled-0_2_w9rh7y.png",
            ],
            carnation: [
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636207/img-8_xeah1b.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636207/img-7_hzirh9.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636204/img-5_koy5ks.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636832/filled-4_sn6mnd.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636834/filled-3_ukp1hd.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636856/filled-2_aurbfg.png",
            ],
            orchid: [
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636219/img-12_spjimp.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636227/img-16_wvlvci.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636220/img-13_oofcme.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636849/filled-0_t10fbi.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636848/filled-10_guyxib.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636839/filled-9_qpc2dd.png",
            ],
            rose: [
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636237/img-19_dksffa.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636245/img-23_vel44w.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636238/img-18_xjxkrf.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636236/img-17_mtu34q.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636853/filled-1_a0npdc.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636836/filled-7_qcnn41.png",
                "https://res.cloudinary.com/dsy30p7gf/image/upload/v1770636838/filled-8_fnbj0j.png",
            ],
        };

        let loadedAssets = {};
        let debounceTimer;
        let visualDebounce;
        const BASE_SIZE = 280;

        function preload() {
            Object.keys(maskUrls).forEach(setName => {
                loadedAssets[setName] = maskUrls[setName].map(url => loadImage(url));
            });
        }

        function setup() {
            const container = document.getElementById('canvas-container');
            const cnv = createCanvas(1, 1);
            cnv.parent('canvas-container');
            cnv.style('display', 'block');
            
            pixelDensity(1);
            frameRate(30);
            updateBackground();

            setTimeout(() => windowResized(), 0);
        }

        function forceAlpha(c) {
            c.setAlpha(255);
            return c;
        }

        function draw() {
            clear();

            const windOn = document.getElementById('chkWind').checked;
            const windForce = parseFloat(document.getElementById('rngWind').value);
            const scrambleOn = document.getElementById('chkScramble').checked;
            const jitterOn = document.getElementById('chkJitter').checked;
            const maskOn = document.getElementById('chkMask').checked;
            const outlineOn = document.getElementById('chkOutline').checked;
            const fillGradientOn = document.getElementById('chkFillGradient').checked;
            const selFont = document.getElementById('selFont').value;
            const fillDir = document.getElementById('selFillDir').value;

            textFont(selFont);

            const fillSolidColor = forceAlpha(color(document.getElementById('colMaskGradA').value));
            const fillGradA = forceAlpha(color(document.getElementById('colMaskGradA').value));
            const fillGradB = forceAlpha(color(document.getElementById('colMaskGradB').value));
            const outlineColor = forceAlpha(color(document.getElementById('colOutlineSolid').value));
            const textColor = color(255); 
            const cStem = color(document.getElementById('colStem').value);

            const time = millis() * 0.001;

            flowers.forEach((f, i) => {
                let swayX = 0, swayRot = 0, bend = f.bend;

                if (windOn) {
                    const noise = sin(time + i + f.x * 0.01) + sin(time * 2 + i);
                    bend += noise * 35 * windForce;
                    swayRot = noise * 0.05 * windForce;
                    swayX = noise * 35 * windForce;
                }

                let depthBrightness = map(f.ty, height * 0.1, height * 0.8, 0.3, 1.0);
                depthBrightness = constrain(depthBrightness, 0.3, 1.0);
                stroke(red(cStem) * depthBrightness, green(cStem) * depthBrightness, blue(cStem) * depthBrightness, 255);
                strokeWeight(lerp(5, 15, f.h / height));
                noFill();

                const p0x = f.x, p0y = height + 10;
                const p2x = f.tx + swayX, p2y = f.ty;
                const p1x = p0x + bend * 0.5, p1y = p2y + (p0y - p2y) * 0.4;

                beginShape();
                for (let t = 0; t <= 1; t += 0.05) {
                    const mt = 1 - t;
                    vertex((mt * mt * p0x) + (2 * mt * t * p1x) + (t * t * p2x), (mt * mt * p0y) + (2 * mt * t * p1y) + (t * t * p2y));
                }
                endShape();

                push();
                translate(p2x, p2y);
                rotate(swayRot);

                let fillT = 0;
                if (fillGradientOn) {
                    if (fillDir === 'vertical') {
                        fillT = constrain(map(f.ty, 0, height, 0, 1), 0, 1);
                    } else if (fillDir === 'horizontal') {
                        fillT = constrain(map(f.tx, 0, width, 0, 1), 0, 1);
                    } else if (fillDir === 'radial') {
                        let d = dist(f.tx, f.ty, width / 2, height / 2);
                        let maxD = dist(0, 0, width / 2, height / 2);
                        fillT = constrain(map(d, 0, maxD, 0, 1), 0, 1);
                    }
                }

                if (maskOn && f.graphic) {
                    const finalFill = fillGradientOn ? forceAlpha(lerpColor(fillGradA, fillGradB, fillT)) : fillSolidColor;
                    tint(finalFill);
                    imageMode(CENTER);
                    noStroke();
                    image(f.graphic, 0, 0);
                    noTint();
                }

                if (outlineOn && f.graphicOutline) {
                    tint(outlineColor);
                    imageMode(CENTER);
                    noStroke();
                    image(f.graphicOutline, 0, 0);
                    noTint();
                }

                noStroke();
                textSize(f.fontSize);
                textAlign(CENTER, CENTER);
                fill(textColor);

                f.points.forEach((p, idx) => {
                    let charIndex = idx % f.chars.length;
                    let dispX = p.x;
                    let dispY = p.y;

                    if (windOn && windForce > 0) {
                        if (scrambleOn && random(3) < windForce * 0.02) {
                            charIndex = floor(random(f.chars.length));
                        }

                        if (jitterOn) {
                            let dynamicChunk = map(f.fontSize, 10, 80, 10, 3);
                            dynamicChunk = floor(constrain(dynamicChunk, 1, 10));
                            const chunkId = floor(idx / dynamicChunk);
                            const snapSpeed = 8.0;
                            const timeStep = floor(time * snapSpeed);
                            let sizeFactor = map(f.fontSize, 10, 80, 0.5, 2.5);
                            sizeFactor = constrain(sizeFactor, 0.5, 3.0);
                            const baseAmp = windForce * 5.0;
                            const amp = baseAmp * sizeFactor;
                            const noiseX = noise(chunkId * 0.1, timeStep * 0.5);
                            const noiseY = noise(chunkId * 0.1 + 500, timeStep * 0.5);
                            const shiftX = map(noiseX, 0, 1, -amp, amp);
                            const shiftY = map(noiseY, 0, 1, -amp, amp);
                            dispX += shiftX;
                            dispY += shiftY;
                        }
                    }

                    text(f.chars[charIndex], dispX, dispY);
                });
                pop();
            });
        }

        function generateGarden() {
            flowers.forEach(f => {
                f.graphic.remove();
                if (f.graphicOutline) f.graphicOutline.remove();
            });
            flowers = [];

            const text = document.getElementById('txtInp').value.trim();
            if (!text) return;

            const baseSize = parseInt(document.getElementById('rngSize').value);
            const sliderScale = parseFloat(document.getElementById('rngScale').value);
            const outlineWidth = parseInt(document.getElementById('rngOutlineWidth').value);

            const setNames = Object.keys(loadedAssets);
            const activeSetName = (targetFlowerSet && loadedAssets[targetFlowerSet]) 
                                  ? targetFlowerSet 
                                  : setNames[Math.floor(Math.random() * setNames.length)];
            lastUsedSet = activeSetName;
            const activeImages = loadedAssets[activeSetName];

            document.getElementById('statusText').innerText = `SET: ${activeSetName.toUpperCase()} | CALC...`;

            const words = text.split(/\s+/);
            const count = constrain(ceil(words.length / 12), 2, 20);
            let densityFactor = (count > 5) ? map(count, 5, 20, 1.0, 0.55) : 1.0;
            const effectiveBaseScale = sliderScale * densityFactor;

            let chunks = [];
            if (words.length < count) {
                for (let i = 0; i < count; i++) chunks.push(text.split(''));
            } else {
                const wordsPerFlower = ceil(words.length / count);
                for (let i = 0; i < count; i++) {
                    let start = i * wordsPerFlower;
                    let segment = words.slice(start, start + wordsPerFlower);
                    if (segment.length > 0) chunks.push(segment.join(' ').split(''));
                }
                while (chunks.length < count) chunks.push(text.split(''));
            }

            const maxW = min(width, 1400);
            for (let i = 0; i < count; i++) {
                let best = null, attempts = 0;
                while (!best && attempts++ < 100) {
                    const scale = effectiveBaseScale * random(0.9, 1.1);
                    const radius = (BASE_SIZE * scale) / 2 + 5;
                    const spread = maxW * map(effectiveBaseScale, 0.5, 2.5, 0.35, 0.5);
                    const tx = width / 2 + random(-spread, spread);
                    const ty = height - (height * random(0.35, 0.85));
                    if (flowers.some(f => dist(tx, ty, f.tx, f.ty) < radius + f.radius)) continue;
                    const img = random(activeImages);
                    const fontSize = baseSize * random(0.9, 1.1);
                    const data = processImage(img, fontSize, scale, outlineWidth);
                    best = {
                        x: width / 2, tx, ty, h: height - ty,
                        bend: random(-100, 100),
                        chars: chunks[i],
                        points: data.points,
                        graphic: data.pg,
                        graphicOutline: data.pgOutline,
                        source: img,
                        fontSize,
                        radius,
                        relScale: scale / sliderScale,
                        relFont: fontSize / baseSize
                    };
                }
                if (best) flowers.push(best);
            }
            flowers.sort((a, b) => a.ty - b.ty);
            document.getElementById('statusText').innerText = `READY | BLOOMS: ${flowers.length}`;
        }

        function updateVisuals() {
            const baseSize = parseInt(document.getElementById('rngSize').value);
            const sliderScale = parseFloat(document.getElementById('rngScale').value);
            const outlineWidth = parseInt(document.getElementById('rngOutlineWidth').value);
            const count = flowers.length;
            let densityFactor = (count > 5) ? map(count, 5, 20, 1.0, 0.55) : 1.0;
            const effectiveBaseScale = sliderScale * densityFactor;

            flowers.forEach(f => {
                const newScale = effectiveBaseScale * f.relScale;
                const newSize = baseSize * f.relFont;
                f.graphic.remove();
                if (f.graphicOutline) f.graphicOutline.remove();
                const data = processImage(f.source, newSize, newScale, outlineWidth);
                f.points = data.points;
                f.graphic = data.pg;
                f.graphicOutline = data.pgOutline;
                f.fontSize = newSize;
                f.radius = (BASE_SIZE * newScale) / 2 + 5;
            });
        }

        function processImage(img, fSize, scale, outlineW) {
            const dim = Math.ceil(BASE_SIZE * scale);
            const pg = createGraphics(dim, dim);
            const pgOutline = createGraphics(dim, dim);
            pg.clear(); pgOutline.clear();

            const asp = img.width / img.height;
            const w = asp >= 1 ? dim : dim * asp;
            const h = asp >= 1 ? dim / asp : dim;
            const dx = (dim - w) / 2;
            const dy = (dim - h) / 2;

            pg.image(img, dx, dy, w, h);
            pg.loadPixels();

            const points = [];
            let spacingFactor = map(fSize, 10, 80, 1.0, 0.6);
            spacingFactor = constrain(spacingFactor, 0.6, 1.0);
            const step = Math.max(fSize * spacingFactor, 2);

            for (let y = 0; y < dim; y += step) {
                for (let x = 0; x < dim; x += step) {
                    const idx = (floor(x) + floor(y) * dim) * 4;
                    if (idx < pg.pixels.length && pg.pixels[idx + 3] > 20) {
                        points.push({ x: x - dim / 2, y: y - dim / 2 });
                    }
                }
            }

            const pW = pg.width;
            const edgePoints = [];
            for (let y = 1; y < dim - 1; y++) {
                for (let x = 1; x < dim - 1; x++) {
                    const i = (x + y * pW) * 4;
                    if (pg.pixels[i + 3] > 0) {
                        if (pg.pixels[i + 3 - 4] === 0 || pg.pixels[i + 3 + 4] === 0 ||
                            pg.pixels[i + 3 - pW * 4] === 0 || pg.pixels[i + 3 + pW * 4] === 0) {
                            edgePoints.push({ x, y });
                        }
                    }
                }
            }
            if (edgePoints.length > 0) {
                pgOutline.stroke(255);
                pgOutline.strokeWeight(outlineW);
                pgOutline.noFill();
                for (let pt of edgePoints) pgOutline.point(pt.x, pt.y);
            }

            for (let i = 0; i < pg.pixels.length; i += 4) {
                if (pg.pixels[i + 3] > 20) {
                    pg.pixels[i] = 255; pg.pixels[i + 1] = 255; pg.pixels[i + 2] = 255; pg.pixels[i + 3] = 255;
                } else {
                    pg.pixels[i + 3] = 0;
                }
            }
            pg.updatePixels();
            return { points, pg, pgOutline };
        }

        function updateBackground() {
            const mode = document.getElementById('selBgMode').value;
            const colA = document.getElementById('colBgGradA').value;
            const colB = document.getElementById('colBgGradB').value;
            const angle = document.getElementById('rngBgAngle').value;
            const url = document.getElementById('inpBgUrl').value;
            const container = document.getElementById('canvas-container');
            const stretchY = document.getElementById('rngBgStretchY').value;

            container.style.background = 'none';
            container.style.backgroundImage = 'none';
            container.style.backgroundSize = 'auto';
            container.style.backgroundRepeat = 'repeat';

            if (mode === 'solid') {
                container.style.backgroundColor = colA;
            } else if (mode === 'gradient') {
                container.style.background = `linear-gradient(${angle}deg, ${colA}, ${colB})`;
            } else if (mode === 'tile') {
                container.style.backgroundImage = `url('${url}')`;
                container.style.backgroundRepeat = 'repeat';
                container.style.backgroundSize = '100px 100px';
            } else if (mode === 'stretch') {
                container.style.backgroundImage = `url('${url}')`;
                container.style.backgroundRepeat = 'no-repeat';
                container.style.backgroundSize = `100% ${stretchY}%`;
            }
        }

        function triggerRegen() { clearTimeout(debounceTimer); debounceTimer = setTimeout(generateGarden, 400); }
        function triggerVisuals() { clearTimeout(visualDebounce); visualDebounce = setTimeout(updateVisuals, 100); }
        function updateUI(id, txt, val, unit) { document.getElementById(id).innerText = `${txt}: ${val}${unit}`; }
        function windowResized() {
            const c = document.getElementById('canvas-container');
            resizeCanvas(c.clientWidth, c.clientHeight);
            generateGarden();
        }
        window.addEventListener("orientationchange", () => setTimeout(windowResized, 300));

        function saveFullArt() {
            const container = document.getElementById('canvas-container');
            const status = document.getElementById('statusText');
            status.innerText = "RENDERING...";
            html2canvas(container, {
                scale: 2, useCORS: true, allowTaint: true, backgroundColor: null, logging: false
            }).then(canvas => {
                const link = document.createElement('a');
                link.download = 'spora_render_' + new Date().getTime() + '.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
                status.innerText = "RENDER COMPLETE";
            }).catch(err => {
                console.error(err);
                status.innerText = "RENDER ERROR";
            });
        }

        function downloadState() {
            const currentState = {
                text: document.getElementById('txtInp').value,
                flowerSet: lastUsedSet, 
                wind: { active: document.getElementById('chkWind').checked, strength: parseFloat(document.getElementById('rngWind').value) },
                chaos: { scramble: document.getElementById('chkScramble').checked, jitter: document.getElementById('chkJitter').checked },
                colors: { 
                    maskA: document.getElementById('colMaskGradA').value, maskB: document.getElementById('colMaskGradB').value, 
                    stem: document.getElementById('colStem').value, bgA: document.getElementById('colBgGradA').value, bgB: document.getElementById('colBgGradB').value 
                },
                style: {
                    fill: { active: document.getElementById('chkMask').checked, gradient: document.getElementById('chkFillGradient').checked, dir: document.getElementById('selFillDir').value },
                    outline: { active: document.getElementById('chkOutline').checked, width: parseInt(document.getElementById('rngOutlineWidth').value) }
                },
                geometry: { 
                    scale: parseFloat(document.getElementById('rngScale').value), fontSize: parseInt(document.getElementById('rngSize').value), font: document.getElementById('selFont').value 
                },
                background: {
                    mode: document.getElementById('selBgMode').value, url: document.getElementById('inpBgUrl').value, 
                    angle: parseInt(document.getElementById('rngBgAngle').value), stretchY: parseInt(document.getElementById('rngBgStretchY').value)
                }
            };
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(currentState, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "spora_state_" +  new Date().getTime() + ".json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }

        function loadStateFromFile(input) {
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const json = JSON.parse(e.target.result);
                    applyVisualState(json);
                    document.getElementById('statusText').innerText = "STATE LOADED";
                } catch (err) {
                    console.error(err);
                    document.getElementById('statusText').innerText = "LOAD ERROR";
                }
            };
            reader.readAsText(file);
            input.value = ''; 
        }

        const moodProfiles = {
            positive: {
                flowerSet: 'daisy',
                wind: { active: true, strength: 0.2 },
                chaos: { scramble: false, jitter: false },
                colors: { maskA: '#CCFF00', maskB: '#FFFFFF', stem: '#00FF00', bgA: '#0000FF', bgB: '#CCFF00' },
                style: { fill: { active: true, gradient: false, dir: 'radial' }, outline: { active: true, width: 2 } },
                geometry: { scale: 1.1, fontSize: 18, font: 'Inter' }
            },
            negative: {
                flowerSet: 'rose',
                wind: { active: true, strength: 0.1 },
                chaos: { scramble: false, jitter: false },
                colors: { maskA: '#000000', maskB: '#FF0000', stem: '#00FF00', bgA: '#FF0000', bgB: '#000000' },
                style: { fill: { active: true, gradient: true, dir: 'vertical' }, outline: { active: true, width: 1 } },
                geometry: { scale: 0.8, fontSize: 12, font: 'UnifrakturMaguntia' }
            },
            chaos: {
                flowerSet: 'carnation',
                wind: { active: true, strength: 2.0 },
                chaos: { scramble: true, jitter: true },
                colors: { maskA: '#FF00FF', maskB: '#00FF00', stem: '#00FF00', bgA: '#1a1a1a', bgB: '#330033' },
                style: { fill: { active: false, gradient: false, dir: 'horizontal' }, outline: { active: true, width: 4 } },
                geometry: { scale: 2, fontSize: 55, font: 'Courier Prime' }
            }
        };

        function randomizeState() {
            const randomColor = () => '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
            const sets = Object.keys(maskUrls);
            const fonts = ['Arial', 'Inter', 'Playfair Display', 'Courier Prime', 'UnifrakturMaguntia'];
            const bgModes = ['gradient', 'solid'];

            const randomProfile = {
                flowerSet: sets[Math.floor(Math.random() * sets.length)],
                wind: { active: Math.random() > 0.5, strength: parseFloat((Math.random() * 2).toFixed(1)) },
                chaos: { scramble: Math.random() > 0.8, jitter: Math.random() > 0.7 },
                colors: { maskA: randomColor(), maskB: randomColor(), stem: randomColor(), bgA: randomColor(), bgB: randomColor() },
                style: {
                    fill: { active: Math.random() > 0.2, gradient: Math.random() > 0.5, dir: ['vertical', 'horizontal', 'radial'][Math.floor(Math.random() * 3)] },
                    outline: { active: Math.random() > 0.3, width: Math.floor(Math.random() * 6) + 1 }
                },
                geometry: { scale: parseFloat((Math.random() * 2 + 0.5).toFixed(1)), fontSize: Math.floor(Math.random() * 70) + 10, font: fonts[Math.floor(Math.random() * fonts.length)] },
                background: {
                    mode: bgModes[Math.floor(Math.random() * bgModes.length)], url: document.getElementById('inpBgUrl').value, 
                    angle: Math.floor(Math.random() * 360), stretchY: 100
                }
            };
            applyVisualState(randomProfile);
            document.getElementById('statusText').innerText = "RANDOM MUTATION APPLIED";
        }

        function applyVisualState(state) {
            if (state.text) document.getElementById('txtInp').value = state.text;
            targetFlowerSet = state.flowerSet || 'daisy';

            document.getElementById('chkWind').checked = state.wind.active;
            document.getElementById('rngWind').value = state.wind.strength;
            updateUI('lblWind', 'FORCE', state.wind.strength, '');

            document.getElementById('chkScramble').checked = state.chaos.scramble;
            document.getElementById('chkJitter').checked = state.chaos.jitter;

            document.getElementById('colMaskGradA').value = state.colors.maskA;
            document.getElementById('colMaskGradB').value = state.colors.maskB;
            document.getElementById('colStem').value = state.colors.stem;
            document.getElementById('colBgGradA').value = state.colors.bgA;
            document.getElementById('colBgGradB').value = state.colors.bgB;

            document.getElementById('chkMask').checked = state.style.fill.active;
            document.getElementById('chkFillGradient').checked = state.style.fill.gradient;
            document.getElementById('selFillDir').value = state.style.fill.dir;
            
            document.getElementById('chkOutline').checked = state.style.outline.active;
            document.getElementById('rngOutlineWidth').value = state.style.outline.width;
            updateUI('lblOutlineWidth', 'WIDTH', state.style.outline.width, 'px');

            document.getElementById('rngScale').value = state.geometry.scale;
            updateUI('lblScale', 'SCALE', state.geometry.scale, 'x');
            document.getElementById('rngSize').value = state.geometry.fontSize;
            updateUI('lblSize', 'SIZE', state.geometry.fontSize, 'px');
            document.getElementById('selFont').value = state.geometry.font;

            if (state.background) {
                document.getElementById('selBgMode').value = state.background.mode;
                document.getElementById('inpBgUrl').value = state.background.url;
                document.getElementById('rngBgAngle').value = state.background.angle;
                document.getElementById('rngBgStretchY').value = state.background.stretchY || 100;
                updateUI('lblBgAngle', 'ANGLE', state.background.angle, 'deg');
                updateUI('lblBgStretchY', 'V-STRETCH', state.background.stretchY || 100, '%');
            }
            updateBackground();
            generateGarden(); 
        }
    </script>
</body>
</html>